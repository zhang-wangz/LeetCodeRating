import fs from 'fs-extra';
import path from 'path';
import micromatch from 'micromatch';
import { fileURLToPath } from 'url';
import image2uri from 'image2uri';
import readdirFiles, { getStat } from 'recursive-readdir-files';
import { autoConf, merge, getConfigPath } from 'auto-config-loader';
import { createRequire } from 'node:module';
import { logo } from './logo.js';
import { isAbsoluteURL, isOutReadme } from '../markdown/utils.js';
import * as log from '../utils/log.js';
import { cacheFile } from './cacheFileStat.js';
const require = createRequire(import.meta.url);
export const cacheCopyiedFiles = [];
const footerStr = `Released under the MIT License. Copyright © {{idocYear}} Kenny Wong<br />Generated by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a> v{{idocVersion}}`;
export class Conf {
    constructor() {
        // this.initConf();
    }
    data = {
        root: process.cwd(),
        dir: '',
        output: '',
        // dir: path.resolve(process.cwd(), 'docs'),
        // output: path.resolve(process.cwd(), 'dist'),
        chapters: [],
        config: {},
        asset: [],
        scope: [],
        scopePrivate: [],
        data: {},
        site: 'idoc',
        logo: {
            base64: logo,
        },
        favicon: {
            base64: logo,
        },
        keywords: '',
        footer: footerStr,
        global: {},
        element: { wrapper: '' },
        page: {},
    };
    get all() {
        return this.data;
    }
    set footer(str) {
        this.data.footer = str
            .replace('{{idocVersion}}', this.data.idocVersion)
            .replace('{{idocYear}}', new Date().getFullYear().toString())
            .replace('{{version}}', this.data.version);
    }
    set logo(src) {
        this.data.logo = transformLogoOrFavicon(src);
    }
    set favicon(src) {
        this.data.favicon = transformLogoOrFavicon(src);
    }
    set all(data) {
        Object.keys(data).forEach((key) => {
            if (key === 'favicon') {
                this.favicon = data[key];
            }
            else if (key === 'logo') {
                this.logo = data[key];
            }
            else if (key === 'footer') {
                this.footer = data[key] || '';
            }
            else {
                this.data[key] = data[key];
            }
        });
    }
    async initConf(options = {}) {
        const pkgpath = path.resolve(this.data.root, 'package.json');
        if (fs.existsSync(pkgpath)) {
            const pkg = await fs.readJSON(pkgpath);
            this.data.version = pkg.version;
            this.data.site = options.site || pkg.title || pkg.name || '';
            this.data.keywords = pkg.keywords && Array.isArray(pkg.keywords) ? pkg.keywords.join(',') : '';
            if (pkg.repository && pkg.repository.url) {
                pkg.repository.url = pkg.repository.url.replace(/^git\+/, '');
            }
            this.data.openSource = pkg.repository || this.data.openSource;
            this.data.homepage = pkg.homepage || this.data.homepage;
        }
        const data = await autoConf('idoc', {
            searchPlaces: ['idoc.yml', '.idoc.yml'],
            ignoreLog: true,
        });
        const defaultDocsPath = path.resolve(process.cwd(), 'docs');
        const defaultOutputPath = path.resolve(process.cwd(), 'dist');
        const idocPkgPath = fileURLToPath(new URL('../../package.json', import.meta.url));
        const idocPkg = require(idocPkgPath);
        this.data = merge(this.data, data || {}, {
            dir: data?.dir ? path.resolve(this.data.root, data.dir) : this.data.dir || defaultDocsPath,
            output: data?.output ? path.resolve(this.data.root, data.output) : this.data.output || defaultOutputPath,
            tocs: data?.tocs === false ? data.tocs : undefined,
            site: options.site || data?.site || this.data.site || '',
            sideEffectFiles: (data?.sideEffectFiles || []).map((filepath) => path.resolve(filepath)),
            idocVersion: idocPkg.version,
            global: data || {},
            config: {
                conf: getConfigPath(),
            },
        });
        this.logo = (data?.logo || logo);
        this.favicon = (data?.favicon || logo);
        if (data) {
            this.initScope();
        }
        this.data.site = this.data.site
            ?.replace('{{version}}', `<sup>${this.data.version}</sup>`)
            .replace(/{{version:(.*?)}}/g, `<sup>$1</sup>`);
        await cacheFile.init(this.data.cacheFileStat);
        await cacheFile.load();
        if (this.data.theme === 'default' || !this.data.theme) {
            this.data.theme = fileURLToPath(new URL('../../themes/default', import.meta.url));
        }
        if (this.data.footer) {
            this.footer = this.data.footer;
        }
        return this.data;
    }
    async getChaptersConf() {
        const data = await autoConf('idoc.chapters', {
            cwd: this.data.root,
            searchPlaces: ['idoc.chapters.yml', '.idoc.chapters.yml'],
            ignoreLog: true,
        });
        this.data = merge(this.data, {
            chapters: data || [],
            config: {
                chapters: getConfigPath(),
            },
        });
        config.data.global.chapters = [...this.data.chapters];
    }
    async getFiles() {
        const { copyAssets = '' } = this.data;
        let files = [];
        if (fs.existsSync(this.data.dir)) {
            files = await readdirFiles(this.data.dir, {
                ignored: /\/(node_modules|\.git)/,
                filter: (filestat) => {
                    if (/.(md|markdown)$/.test(filestat.path)) {
                        cacheFile.add(filestat);
                    }
                    return (/.(md|markdown)$/.test(filestat.path) || (copyAssets && micromatch.contains(filestat.path, copyAssets)));
                },
            });
        }
        this.data.asset = files;
        const { sideEffectFiles = [] } = this.data;
        await Promise.all(sideEffectFiles.map(async (filename) => {
            if (!fs.existsSync(filename)) {
                log.log('\x1b[31;1mcreate\x1b[0m')(filename);
                console.log(`    ╰┈\x1b[31;1m FAIL\x1b[0m ->`, `Markdown file \x1b[33;1m${filename}\x1b[0m does not exist. \n`, `              Please check your configuration.`);
                return;
            }
            const stat = await getStat(path.resolve(filename));
            if (/.(md|markdown)$/.test(stat.path)) {
                cacheFile.add(stat);
            }
            this.data.asset.push(stat);
        }));
    }
    async getReadme() {
        const readmePath = path.resolve(this.data.root, 'README.md');
        const readmeDirPath = path.resolve(this.data.dir, 'README.md');
        const existsReadmeDir = this.data.asset.find((item) => item.path === readmeDirPath);
        const existsReadme = this.data.asset.find((item) => isOutReadme(item.path));
        if (existsReadmeDir) {
            this.data.readme = existsReadmeDir.path;
        }
        else if (fs.existsSync(readmePath) && !existsReadme) {
            this.data.readme = readmePath;
            const stat = await getStat(readmePath);
            this.data.asset.push(stat);
            config.data.global.asset = [...this.data.asset];
        }
    }
    initScope() {
        const { menus = {} } = this.data;
        Object.keys(menus).forEach((key) => {
            const url = menus[key];
            const urlhref = typeof url === 'object' ? url.url : url;
            const [_, scope] = urlhref
                .split(' ')
                .map((val) => (val || '').trim())
                .filter(Boolean);
            if (scope && !this.data.scope.includes(scope)) {
                this.data.scope.push(scope.trim());
            }
        });
    }
    getRelativePath(toPath) {
        const rel = path.relative(path.dirname(toPath), config.data.output).split(path.sep).join('/');
        return rel ? rel + '/' : '';
    }
    getMenuData(toPath) {
        const data = [];
        const scope = [...this.data.scope].find((item) => isScope(toPath, item));
        if (this.data.menus) {
            Object.keys(this.data.menus).forEach((key) => {
                const url = this.data.menus[key];
                const urlhref = typeof url === 'object' ? url.url : url;
                const [value] = (urlhref || '')
                    .split(' ')
                    .map((val) => (val || '').trim())
                    .filter(Boolean);
                const menu = { name: key, raw: value, target: '' };
                if (typeof url === 'object' && url.target) {
                    menu.target = url.target;
                }
                const current = path.join(this.data.output, value);
                menu.active = isScope(current, scope) || isActive(current, toPath);
                if (isAbsoluteURL(value)) {
                    menu.url = value;
                }
                else if (toPath === current) {
                    menu.url = path.basename(current);
                }
                else {
                    const rel = path.relative(path.dirname(toPath), path.dirname(path.join(this.data.output, value)));
                    if (!rel) {
                        menu.url = path.basename(value);
                    }
                    else if (rel.startsWith('..')) {
                        menu.url = path.join(rel, path.basename(value)).split(path.sep).join('/');
                    }
                    else if (rel) {
                        menu.url = path.relative(path.dirname(toPath), current).split(path.sep).join('/');
                    }
                    else {
                        menu.url = value;
                    }
                }
                data.push(menu);
            });
        }
        return data;
    }
}
export function transformLogoOrFavicon(opts) {
    const data = typeof opts === 'object' ? { raw: '', ...opts } : { raw: opts || '' };
    if (/^data:image\//.test(data.raw)) {
        data.base64 = data.raw;
    }
    const filePath = path.resolve(config.data.root, data.raw);
    if (fs.existsSync(filePath) && data.raw) {
        data.path = filePath;
        const output = getOutputCurrentPath(filePath);
        data.href = path.relative(config.data.output, output).split(path.sep).join('/');
        fs.ensureDirSync(path.dirname(output));
        fs.copyFileSync(filePath, output);
        // log.output('\x1b[35;1mcopy:favicon\x1b[0m')(filePath, output);
        if (data.raw.toLocaleLowerCase().endsWith('.svg')) {
            data.code = fs.readFileSync(path.resolve(config.data.root, data.raw)).toString();
        }
        data.base64 = image2uri(filePath);
    }
    return data;
}
export function getOutputCurrentPath(current) {
    return path.resolve(config.data.output, path.relative(config.data.root, current));
}
export const isIncludesDocs = (assetPath) => assetPath.startsWith(config.data.dir);
export function isScope(toPath, scope) {
    if (scope) {
        scope = scope.split(path.sep).join(path.sep);
        let relative = path.relative(config.data.output, toPath).split(path.sep).join(path.sep);
        if (new RegExp(`^${scope.split(path.sep).join(path.sep)}`, 'i').test(relative)) {
            return true;
        }
    }
    return false;
}
export function isActive(from, toPath) {
    from = from.split(path.sep).join(path.sep);
    toPath = toPath.split(path.sep).join(path.sep);
    if (from === toPath) {
        return true;
    }
    const formatFrom = path.dirname(from).replace(config.data.output, '');
    const formatToPath = toPath.replace(config.data.output, '');
    if (formatFrom && formatToPath.includes(formatFrom)) {
        return true;
    }
    return false;
}
export const config = new Conf();
