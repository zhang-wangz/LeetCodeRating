import path from 'path';
import fs from 'fs-extra';
import { render } from 'ejs';
import { parse } from 'yaml';
import markdownToHTML from '@wcj/markdown-to-html';
import formatter from '@uiw/formatter';
import { unified } from 'unified';
import autolinkHeadings from 'rehype-autolink-headings';
import rehypeParse from 'rehype-parse';
import rehypeMinifyWhitespace from 'rehype-minify-whitespace';
import rehypeStringify from 'rehype-stringify';
import rehypeRaw from 'rehype-raw';
import ignore from 'rehype-ignore';
import rehypeVideo from 'rehype-video';
import rehypeFormat from 'rehype-format';
import { getCodeString } from 'rehype-rewrite';
import slug from 'rehype-slug';
import { remarkAlert } from 'remark-github-blockquote-alert';
import rehypeTitle from './rehype-title.js';
import { config } from '../utils/conf.js';
import rehypeUrls from './rehype-urls.js';
import { formatChapters } from '../utils/chapters.js';
import { addCopyButton } from './copyButton.js';
import { copyAsset } from './copyAsset.js';
import { codePreview, codePreviewWarpperStyle } from './codePreview.js';
import { getPrevOrNextPage } from './utils.js';
import * as log from '../utils/log.js';
import { getTocsTree } from './tocsTree.js';
import { cacheFile } from '../utils/cacheFileStat.js';
export async function formatHTML(html = '') {
    const plugins = [];
    if (config.data.minify) {
        plugins.push(rehypeMinifyWhitespace);
    }
    else {
        plugins.push(rehypeFormat);
    }
    const file = await unified().use(rehypeParse).use(plugins).use(rehypeStringify).process(html);
    return String(file);
}
export async function createHTML(mdStr = '', fromPath, toPath) {
    const mdOptions = {};
    mdOptions.remarkPlugins = [[remarkAlert, { legacyTitle: true }]];
    mdOptions.rehypePlugins = [
        [
            ignore,
            {
                openDelimiter: 'idoc:ignore:start',
                closeDelimiter: 'idoc:ignore:end',
            },
        ],
        [
            rehypeVideo,
            {
                test: (url) => {
                    return (/\/(.*)(.mp4|.mov)$/i.test(url.replace(/(\?|!|\#|$).+/g, '').toLocaleLowerCase()) ||
                        (/\.(mp4|mov)|[?&]rehype=video/i.test(url) && /https:\/\/github.com\//.test(url)));
                },
            },
        ],
        [slug],
        [autolinkHeadings],
    ];
    const tocs = [];
    let tocsStart = 6;
    let configMarkdownStr = '';
    let pagetitle = '';
    let description = '';
    mdOptions.filterPlugins = (type, plugins) => {
        if (type === 'rehype') {
            plugins.unshift([
                rehypeTitle,
                (title = '', dis = '') => {
                    pagetitle = title;
                    description = dis;
                },
            ]);
            plugins.unshift([rehypeRaw, {}]);
            plugins.unshift([codePreview, {}]);
        }
        return plugins;
    };
    mdOptions.rewrite = (node, index, parent) => {
        codePreviewWarpperStyle(node);
        rehypeUrls(node, fromPath);
        copyAsset(node, fromPath);
        addCopyButton(node);
        if (node.type == 'element' &&
            /h(1|2|3|4|5|6)/.test(node.tagName) &&
            node.children &&
            Array.isArray(node.children) &&
            node.children.length > 0) {
            const num = Number(node.tagName.replace('h', ''));
            const tocItem = { number: num };
            tocItem.href = node.properties.id;
            if (num < tocsStart)
                tocsStart = num;
            node.children = node.children.map((item) => {
                if (item.type === 'element' &&
                    item.tagName === 'a' &&
                    item.children[0] &&
                    item.children[0].type === 'element' &&
                    item.children[0].properties &&
                    item.children[0].properties.className) {
                    if (item.children[0].properties.className.toString().indexOf('icon-link') > -1) {
                        item.properties.class = 'anchor';
                    }
                }
                return item;
            });
            tocItem.label = getCodeString(node.children) || '';
            tocs.push(tocItem);
        }
        if (node.type === 'comment' && /^idoc:config:/i.test(node.value.trimStart())) {
            configMarkdownStr = node.value.replace(/^idoc:config:/i, '');
        }
        if (config.data.rewrite && typeof config.data.rewrite === 'function') {
            config.data.rewrite(node, index, parent);
        }
    };
    const mdHtml = (await markdownToHTML(mdStr, mdOptions));
    const tocsArr = tocs.map((item) => ({
        ...item,
        class: `toc${item.number - tocsStart + 1}`,
    }));
    const data = {
        fileStat: {},
        tocs: [...tocsArr],
        tocsTree: getTocsTree([...tocs.filter((item) => item.number !== 1)]),
        menus: [],
        editButton: {},
    };
    data.version = config.data.version;
    data.idocVersion = config.data.idocVersion;
    data.RELATIVE_PATH = config.getRelativePath(toPath);
    data.RESOLVE_PATH = path.relative(config.data.output, toPath).split(path.sep).join('/');
    const { global, ...other } = config.data;
    config.data.global = { ...other };
    data.chapters = formatChapters(config.data.chapters, toPath);
    // Markdown comment config.
    const page = parse(configMarkdownStr) || {};
    if (typeof page.tocs === 'boolean' && page.tocs === false) {
        data.tocs = page.tocs;
    }
    if (config.data.tocs === false && page.tocs !== true) {
        data.tocs = false;
        data.tocsTree = [];
    }
    // Paging....
    page.prevPage = getPrevOrNextPage('prev', page.prevPage || {}, data.chapters, fromPath, toPath);
    page.nextPage = getPrevOrNextPage('next', page.nextPage || {}, data.chapters, fromPath, toPath);
    config.all = {
        site: page.site || config.data.site,
        keywords: page.keywords || config.data.keywords,
        favicon: page.favicon || config.data.favicon,
        logo: page.logo || config.data.logo,
        title: page.title || pagetitle.replace(/\n/g, '').trim().slice(0, 120) || config.data.title,
        description: page.description || description.replace(/\n/g, '').trim().slice(0, 120) || config.data.description,
        footer: page.footer || config.data.footer || '',
        editButton: page.editButton || config.data.editButton,
        openSource: page.openSource || config.data.openSource,
        page,
    };
    if (config.data.editButton && config.data.editButton.url) {
        data.editButton.label = config.data.editButton.label;
        data.editButton.url = `${config.data.editButton.url.replace(/\/$/, '')}/${path.relative(config.data.root, fromPath)}`;
    }
    if (config.data.menus) {
        data.menus = config.getMenuData(toPath);
    }
    // File Stat
    data.fileStat = config.data.asset.find((item) => item.path === fromPath) || {};
    const cacheFileStat = cacheFile.get(data.fileStat.path);
    data.fileStat = { ...data.fileStat, ...cacheFileStat, ...page.fileStat };
    const getKeys = (obj) => Object.keys(obj);
    for (const key of getKeys(data.fileStat)) {
        if ((key === 'atime' || key === 'ctime' || key === 'mtime') && data.fileStat[key]) {
            const date = data.fileStat[key] instanceof Date ? data.fileStat[key] : new Date(data.fileStat[key]);
            data.fileStat = { ...data.fileStat, ...{ [`${key}Str`]: formatter('YYYY/MM/DD', date) } };
        }
    }
    const varData = {
        meta: [],
        ...config.all,
        ...data,
        giscusScript: '',
        menus: data.menus,
        page,
        markdown: mdStr,
        html: mdHtml,
    };
    if (varData.meta && Array.isArray(varData.meta)) {
        varData.meta = varData.meta.map((item) => render(item || '', { ...varData }, {}));
    }
    if (config.data.giscus) {
        const resultGiscus = Object.keys(config.data.giscus).map((key) => `${key}="${config.data.giscus[key]}"`);
        varData.giscusScript = `<script ${resultGiscus.join(' ')} data-script-id="giscus"></script><div class=".giscus"></div>`;
    }
    let tempPath = path.resolve(config.data.theme, page.layout || 'markdown.ejs');
    if (page.layout) {
        tempPath = path.resolve(config.data.root, page.layout);
    }
    if (!fs.existsSync(tempPath)) {
        log.log('\x1b[31;1mcreate\x1b[0m')(fromPath);
        console.log(`    ╰┈\x1b[31;1m FAIL\x1b[0m ->`, `Template \x1b[33;1m${tempPath}\x1b[0m does not exist. \n`, `              Please check your configuration.`);
        return '';
    }
    try {
        const tmpStr = await fs.readFile(tempPath);
        const htmlStr = render(tmpStr.toString(), varData, {
            filename: tempPath,
            rmWhitespace: true,
        });
        return formatHTML(htmlStr);
    }
    catch (error) {
        console.log(`    ╰┈\x1b[31;1m FAIL\x1b[0m ->`, `please check template \x1b[33;1m${tempPath}\x1b[0m.\n`, `              Error: \x1b[31;1m${error.message || error}\x1b[0m.`);
        return error.message || error;
    }
}
